<!DOCTYPE html>
<html lang="en">
    <!-- title -->


    

<!-- keywords -->



<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="John Doe">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="John Doe">
    
        <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content="">
    <meta name="description" content="应用层1.HTTP 头部包含哪些信息12HTTP 头部本质上是一个传递额外重要信息的键值对。主要分为：通用头部，请求头部，响应头部和实体头部    2.Keep-Alive 和非 Keep-Alive 区别，对服务器性能有影响吗区别： 123早期的 HTTP&#x2F;1.0 中，浏览器每次发起 HTTP 请求都要与服务器创建一个新的 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="http://example.com/2022/05/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="应用层1.HTTP 头部包含哪些信息12HTTP 头部本质上是一个传递额外重要信息的键值对。主要分为：通用头部，请求头部，响应头部和实体头部    2.Keep-Alive 和非 Keep-Alive 区别，对服务器性能有影响吗区别： 123早期的 HTTP&#x2F;1.0 中，浏览器每次发起 HTTP 请求都要与服务器创建一个新的 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pic.leetcode-cn.com/1612195694-ROTKiX-%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1627875372-TxeGlX-image.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1632307681-keCKRT-image.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1612459029-slhrTZ-%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%9B%BE.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1614160878-FiFlkq-image.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1612459478-ajInIu-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1627570368-YNpFKD-image.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1627571339-xeuBNe-image.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1612460049-DzVGiO-%E6%97%A0%E5%B7%AE%E9%94%99%E5%92%8C%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1612460087-MRLQIm-%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E5%92%8C%E7%A1%AE%E8%AE%A4%E9%87%8D%E4%BC%A0.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1618208921-kuMbas-image.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1612460289-ImAroH-TCP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png">
<meta property="article:published_time" content="2022-05-09T12:14:40.529Z">
<meta property="article:modified_time" content="2022-05-09T12:36:01.468Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.leetcode-cn.com/1612195694-ROTKiX-%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5.png">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="icon" href="/assets/favicon.ico">
    
    <title>计算机网络 · echowrn&#39;s Hogwarts.</title>
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
    (function (w) {
        'use strict'
        // rel=preload support test
        if (!w.loadCSS) {
            w.loadCSS = function () {}
        }
        // define on the loadCSS obj
        var rp = (loadCSS.relpreload = {})
        // rel=preload feature support test
        // runs once and returns a function for compat purposes
        rp.support = (function () {
            var ret
            try {
                ret = w.document.createElement('link').relList.supports('preload')
            } catch (e) {
                ret = false
            }
            return function () {
                return ret
            }
        })()

        // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
        // then change that media back to its intended value on load
        rp.bindMediaToggle = function (link) {
            // remember existing media attr for ultimate state, or default to 'all'
            var finalMedia = link.media || 'all'

            function enableStylesheet() {
                link.media = finalMedia
            }

            // bind load handlers to enable media
            if (link.addEventListener) {
                link.addEventListener('load', enableStylesheet)
            } else if (link.attachEvent) {
                link.attachEvent('onload', enableStylesheet)
            }

            // Set rel and non-applicable media type to start an async request
            // note: timeout allows this to happen async to let rendering continue in IE
            setTimeout(function () {
                link.rel = 'stylesheet'
                link.media = 'only x'
            })
            // also enable media after 3 seconds,
            // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
            setTimeout(enableStylesheet, 3000)
        }

        // loop through link elements in DOM
        rp.poly = function () {
            // double check this to prevent external calls from running
            if (rp.support()) {
                return
            }
            var links = w.document.getElementsByTagName('link')
            for (var i = 0; i < links.length; i++) {
                var link = links[i]
                // qualify links to those with rel=preload and as=style attrs
                if (
                    link.rel === 'preload' &&
                    link.getAttribute('as') === 'style' &&
                    !link.getAttribute('data-loadcss')
                ) {
                    // prevent rerunning on link
                    link.setAttribute('data-loadcss', true)
                    // bind listeners to toggle media back
                    rp.bindMediaToggle(link)
                }
            }
        }

        // if unsupported, run the polyfill
        if (!rp.support()) {
            // run once at least
            rp.poly()

            // rerun poly on an interval until onload
            var run = w.setInterval(rp.poly, 500)
            if (w.addEventListener) {
                w.addEventListener('load', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            } else if (w.attachEvent) {
                w.attachEvent('onload', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            }
        }

        // commonjs
        if (typeof exports !== 'undefined') {
            exports.loadCSS = loadCSS
        } else {
            w.loadCSS = loadCSS
        }
    })(typeof global !== 'undefined' ? global : this)
</script>

    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }
</style>

    <link rel="preload" href="/css/style.css?v=20211217" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="/css/dark.css?v=20211217" as="style">
    <link rel="stylesheet" href="/css/dark.css">
    <link rel="stylesheet" href="/css/mobile.css?v=20211217" media="(max-width: 960px)">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js?v=20211217" as="script">
    <link rel="preload" href="/scripts/dark.js?v=20211217" as="script">
    <link rel="preload" href="/font/Oswald-Regular.ttf" as="font" crossorigin>
    <link rel="preload" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" as="font" crossorigin>
    <!-- algolia -->
    
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 6.1.0"></head>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ == undefined) {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js" />')
        }
    </script>
    
        <body class="post-body">
    
        <!-- header -->
        <header class="header header-mobile">
    <!-- top read progress line -->
    <div class="header-element">
        <div class="read-progress"></div>
    </div>
    <!-- sidebar menu button -->
    <div class="header-element">
        
            <div class="header-sidebar-menu">
        
            
                <div style="padding-left: 1px;">&#xe775;</div>
            
        </div>
    </div>
    <!-- header actions -->
    <div class="header-actions">
        <!-- theme mode switch button -->
        <span class="header-theme-btn header-element">
            <i class="fas fa-adjust"></i>
        </span>
        <!-- back to home page text -->
        <span class="home-link header-element">
            <a href=/>echowrn's Hogwarts.</a>
        </span>
    </div>
    <!-- toggle banner for post layout -->
    
        
            <div class="banner">
        
            <div class="blog-title header-element">
                <a href="/">echowrn&#39;s Hogwarts.</a>
            </div>
            <div class="post-title header-element">
                <a href="#" class="post-name">计算机网络</a>
            </div>
        </div>
    
</header>

        <!-- fixed footer -->
        <footer class="footer-fixed">
    <!-- back to top button -->
    <div class="footer-fixed-element">
        
            <div class="back-top back-top-hidden">
        
        
            <div>&#xe639;</div>
        
        </div>
    </div>
</footer>

        <!-- wrapper -->
        <div class="wrapper">
            <div class="site-intro" style="







    height:50vh;

">
    
    <!-- 主页  -->
    
        
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
                计算机网络
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
                
            <!-- 404 -->
            
        </p>
        <!-- 文章页 meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
    
        <a class="post-tag" href="javascript:void(0);" data-tags="计算机网络">计算机网络</a>
    
</div>

                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">10.5k</span>Reading time: <span class="post-count reading-time">37 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <!-- 撰写日期 -->
                    <span class="iconfont-archer post-intro-calander">&#xe676;</span>
                    <span class="post-intro-time">2022/05/09</span>
                    <!-- busuanzi -->
                    
                        <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                            <span class="iconfont-archer post-intro-busuanzi">&#xe602;</span>
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    
                    <!-- 文章分享 -->
                    <span class="share-wrapper">
                        <span class="iconfont-archer share-icon">&#xe71d;</span>
                        <span class="share-text">Share</span>
                        <ul class="share-list">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>

            <script>
  // get user agent
  function getBrowserVersions() {
    var u = window.navigator.userAgent
    return {
      userAgent: u,
      trident: u.indexOf('Trident') > -1, //IE内核
      presto: u.indexOf('Presto') > -1, //opera内核
      webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
      gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
      mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
      ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
      android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
      iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
      iPad: u.indexOf('iPad') > -1, //是否为iPad
      webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
      weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
      uc: u.indexOf('UCBrowser') > -1, //是否为android下的UC浏览器
    }
  }
  var browser = {
    versions: getBrowserVersions(),
  }
  console.log('userAgent: ' + browser.versions.userAgent)

  // callback
  function fontLoaded() {
    console.log('font loaded')
    if (document.getElementsByClassName('site-intro-meta')) {
      document
        .getElementsByClassName('intro-title')[0]
        .classList.add('intro-fade-in')
      document
        .getElementsByClassName('intro-subtitle')[0]
        .classList.add('intro-fade-in')
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in')
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb() {
    if (browser.versions.uc) {
      console.log('UCBrowser')
      fontLoaded()
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular'],
        },
        loading: function () {
          // 所有字体开始加载
          // console.log('font loading');
        },
        active: function () {
          // 所有字体已渲染
          fontLoaded()
        },
        inactive: function () {
          // 字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout')
          fontLoaded()
        },
        timeout: 5000, // Set the timeout to two seconds
      })
    }
  }

  function asyncErr() {
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0]
    o.src = u
    if (cb) {
      o.addEventListener(
        'load',
        function (e) {
          cb(null, e)
        },
        false
      )
    }
    if (err) {
      o.addEventListener(
        'error',
        function (e) {
          err(null, e)
        },
        false
      )
    }
    s.parentNode.insertBefore(o, s)
  }

  var asyncLoadWithFallBack = function (arr, success, reject) {
    var currReject = function () {
      reject()
      arr.shift()
      if (arr.length) async(arr[0], success, currReject)
    }

    async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack(
    [
      'https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js',
      'https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js',
      "/lib/webfontloader.min.js",
    ],
    asyncCb,
    asyncErr
  )
</script>

            <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
            <div class="container container-unloaded">
                <main class="main post-page">
    <article class="article-entry">
        <h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="1-HTTP-头部包含哪些信息"><a href="#1-HTTP-头部包含哪些信息" class="headerlink" title="1.HTTP 头部包含哪些信息"></a>1.HTTP 头部包含哪些信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP 头部本质上是一个传递额外重要信息的键值对。</span><br><span class="line">主要分为：通用头部，请求头部，响应头部和实体头部</span><br></pre></td></tr></table></figure>



<h3 id="2-Keep-Alive-和非-Keep-Alive-区别，对服务器性能有影响吗"><a href="#2-Keep-Alive-和非-Keep-Alive-区别，对服务器性能有影响吗" class="headerlink" title="2.Keep-Alive 和非 Keep-Alive 区别，对服务器性能有影响吗"></a>2.Keep-Alive 和非 Keep-Alive 区别，对服务器性能有影响吗</h3><p>区别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">早期的 HTTP/1.0 中，浏览器每次发起 HTTP 请求都要与服务器创建一个新的 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。</span><br><span class="line"></span><br><span class="line">在 HTTP/1.1 版本中默认使用持久连接，在此之前的 HTTP 版本的默认连接都是使用非持久连接，如果想要在旧版本的 HTTP 协议上维持持久连接，则需要指定 connection 的首部字段的值为 Keep-Alive 来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。</span><br></pre></td></tr></table></figure>

<img src="https://pic.leetcode-cn.com/1612195694-ROTKiX-%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5.png" alt="长连接和短连接.png" style="zoom: 33%;" />

<p>对服务器性能的影响：</p>
<pre><code>    对于非 Keep-Alive 来说，必须为每一个请求的对象建立和维护一个全新的连接。对于每一个这样的连接，客户机和服务器都要分配 TCP 的缓冲区和变量，这给服务器带来的严重的负担，因为一台 Web 服务器可能同时服务于数以百计的客户机请求。在 Keep-Alive 方式下，服务器在响应后保持该 TCP 连接打开，在同一个客户机与服务器之间的后续请求和响应报文可通过相同的连接进行传送。甚至位于同一台服务器的多个 Web 页面在从该服务器发送给同一个客户机时，可以在单个持久 TCP 连接上进行。
</code></pre>
<p>keep-Alive缺点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Keep-Alive 并不是没有缺点的，当长时间的保持 TCP 连接时容易导致系统资源被无效占用，若对 Keep-Alive 模式配置不当，将有可能比非 Keep-Alive 模式带来的损失更大。因此，我们需要正确地设置 keep-alive timeout 参数，当 TCP 连接在传送完最后一个 HTTP 响应，该连接会保持 keepalive_timeout 秒，之后就开始关闭这个链接。</span><br></pre></td></tr></table></figure>

<h3 id="3-HTTP-长连接短连接使用场景是什么"><a href="#3-HTTP-长连接短连接使用场景是什么" class="headerlink" title="3.HTTP 长连接短连接使用场景是什么"></a>3.HTTP 长连接短连接使用场景是什么</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">长连接(持久连接)：多用于操作频繁，点对点的通讯，而且客户端连接数目较少的情况。例如即时通讯、网络游戏等。</span><br><span class="line"></span><br><span class="line">短连接：用户数目较多的Web网站的 HTTP 服务一般用短连接。例如京东，淘宝这样的大型网站一般客户端数量达到千万级甚至上亿，若采用长连接势必会使得服务端大量的资源被无效占用，所以一般使用的是短连接。</span><br></pre></td></tr></table></figure>

<p>区分TCP长连接和HTTP长连接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP长连接通过Client和Server的一些关闭策略实现</span><br><span class="line">TCP长连接是通过HTTP1.1头部信息KeepAlive实现</span><br></pre></td></tr></table></figure>

<h3 id="4-怎么知道-HTTP-的报文长度"><a href="#4-怎么知道-HTTP-的报文长度" class="headerlink" title="4.怎么知道 HTTP 的报文长度"></a>4.怎么知道 HTTP 的报文长度</h3><p>服务器在响应报文中有两种表现形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于小点的文件，直接给出 content-length,也就是本次返回的数据长度</span><br><span class="line">对于大文件，使用 Transfer-Encoding:chunked 字段，不传输数据长度，客户端只知道是分组传输，这也是订好了协议，客户端收到了会进行组装。</span><br></pre></td></tr></table></figure>

<p>分组传输编码规则：</p>
<img src="https://pic.leetcode-cn.com/1627875372-TxeGlX-image.png" alt="分组传输编码规则" style="zoom:25%;" />



<h3 id="5-HTTP-方法了解哪些"><a href="#5-HTTP-方法了解哪些" class="headerlink" title="5.HTTP 方法了解哪些"></a>5.HTTP 方法了解哪些</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http1.0：</span><br><span class="line">get（读取数据）、head（获取报头）、post（提交数据处理请求）；</span><br><span class="line"></span><br><span class="line">http1.1：（增加）</span><br><span class="line">put（增或换）、delete（删除）、options（返回支持方法）、connect（server代理访问）、trace（服务器返回接收数据）、patch（局部更新）</span><br></pre></td></tr></table></figure>

<h3 id="6-GET-和-POST-的区别"><a href="#6-GET-和-POST-的区别" class="headerlink" title="6.GET 和 POST 的区别"></a>6.GET 和 POST 的区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于GET方式的请求，浏览器会把http header和data一并发送出去，服务端响应200，请求成功。</span><br><span class="line"></span><br><span class="line">对于POST方式的请求，浏览器会先发送http header给服务端，告诉服务端等一下会有数据过来，服务端响应100 continue，告诉浏览器我已经准备接收数据，浏览器再post发送一个data给服务端，服务端响应200，请求成功。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>操作方式</th>
<th>数据位置</th>
<th><strong>明文密文</strong></th>
<th><strong>数据安全</strong></th>
<th><strong>长度限制</strong></th>
<th><strong>应用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>HTTP包头（URL之后）</td>
<td>明文</td>
<td>不安全</td>
<td>长度较小</td>
<td>查询数据</td>
</tr>
<tr>
<td>POST</td>
<td>HTTP正文</td>
<td>可明可密</td>
<td>安全</td>
<td>支持较大数据传输</td>
<td>修改数据</td>
</tr>
</tbody></table>
<h3 id="7-GET-的长度限制是多少"><a href="#7-GET-的长度限制是多少" class="headerlink" title="7.GET 的长度限制是多少"></a>7.GET 的长度限制是多少</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP 中的 GET 方法是通过 URL 传递数据的，而 URL 本身并没有对数据的长度进行限制，真正限制 GET 长度的是浏览器。</span><br><span class="line"></span><br><span class="line">由于 POST 方法请求参数在请求主体中，理论上讲，post 方法是没有大小限制的，而真正起限制作用的是服务器处理程序的处理能力。</span><br></pre></td></tr></table></figure>

<p>URL构成：<code>协议</code> + <code>://</code> + <code>认证信息</code> + <code>@</code> + <code>域名 or IP地址</code> + <code>端口号</code> + <code>资源路径</code> + <code>?</code> + <code>查询字符串</code> + <code>#</code> + <code>片段标识符</code></p>
<p>整个URL 的长度，就是指包含上述所有组成部分在内的总长度，数据部分就是指查询字符串。</p>
<h3 id="8-HTTP-与-HTTPs-的工作方式【建立连接的过程】"><a href="#8-HTTP-与-HTTPs-的工作方式【建立连接的过程】" class="headerlink" title="8.HTTP 与 HTTPs 的工作方式【建立连接的过程】"></a>8.HTTP 与 HTTPs 的工作方式【建立连接的过程】</h3><p>​	HTTP（Hyper Text Transfer Protocol: 超文本传输协议） 是一种简单的请求 - 响应协议，被用于在 Web 浏览器和网站服务器之间传递消息。</p>
<p>​	HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是以安全为目标的 HTTP 协议，在 HTTP 的基础上通过<strong>传输加密</strong>和<strong>身份认证</strong>的方式保证了传输过程的安全性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HTTP:默认用TCP协议的80端口（可以改），通信内容明文传输，不处理</span><br><span class="line">HTTPS:</span><br><span class="line">1.请求：443端口，支持算法，密钥长度</span><br><span class="line">理解：两网友约定明天出去玩，玩什么呢？爬山，游泳，游乐园选一个吧</span><br><span class="line">2.响应：选择一种，将其密钥组件一起发给客户端</span><br><span class="line">理解：我们去游乐园吧</span><br><span class="line">3.响应：数字证书</span><br><span class="line">理解：为了证明我是个合法公民。给你看看我的身份证，身份证是XX公安局发的，身份证号是XX,10年后过期</span><br><span class="line">4.响应：协商完成</span><br><span class="line">理解：OK，我同意去游乐园</span><br><span class="line">5.生成随机密码串，并使用证书公钥加密</span><br><span class="line">理解：为了互相证明我们是协商的网友，每个句尾加个“喵”</span><br><span class="line">6.请求：尝试使用加密串加密</span><br><span class="line">理解：我们试试，我是客户端喵</span><br><span class="line">7.响应：发送finish结束</span><br><span class="line">理解：我说完了你试试</span><br><span class="line">8.响应：和客户端相同进行加密发送</span><br><span class="line">理解：服务端喵</span><br><span class="line">然后，SSL链接完成</span><br></pre></td></tr></table></figure>

<h3 id="9-HTTPS-和-HTTP-的区别"><a href="#9-HTTPS-和-HTTP-的区别" class="headerlink" title="9.HTTPS 和 HTTP 的区别"></a>9.HTTPS 和 HTTP 的区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.HTTP 协议以明文方式发送内容，数据都是未加密的，安全性较差。2.HTTPS 数据传输过程是加密的，安全性较好。</span><br><span class="line">3.HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 端口，后者是 443 端口。</span><br><span class="line">4.HTTPS 协议需要到数字认证机构（Certificate Authority, CA）申请证书，一般需要一定的费用。</span><br><span class="line">5.HTTP 页面响应比 HTTPS 快，主要因为 HTTP 使用 3 次握手建立连接，客户端和服务器需要握手 3 次，而 HTTPS 除了 TCP 的 3 次握手，还需要经历一个 SSL 协商过程。</span><br></pre></td></tr></table></figure>

<h3 id="10-HTTPS-的加密方式"><a href="#10-HTTPS-的加密方式" class="headerlink" title="10.HTTPS 的加密方式"></a>10.HTTPS 的加密方式</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43789231">https://zhuanlan.zhihu.com/p/43789231</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTPS 采用对称加密和非对称加密相结合的方式，首先使用 SSL/TLS 协议进行加密传输，为了弥补非对称加密的缺点，HTTPS 采用证书来进一步加强非对称加密的安全性，通过非对称加密，客户端和服务端协商好之后进行通信传输的对称密钥，后续的所有信息都通过该对称秘钥进行加密解密，完成整个 HTTPS 的流程。</span><br></pre></td></tr></table></figure>

<h3 id="11-客户端为什么信任第三方证书"><a href="#11-客户端为什么信任第三方证书" class="headerlink" title="11.客户端为什么信任第三方证书"></a>11.客户端为什么信任第三方证书</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设中间人篡改了证书原文，由于他没有 CA 机构的私钥，所以无法得到此时加密后的签名，因此无法篡改签名。客户端浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书被中间人篡改，证书不可信，从而终止向服务器传输信息。</span><br><span class="line"></span><br><span class="line">上述过程说明证书无法被篡改，我们考虑更严重的情况，例如中间人拿到了 CA 机构认证的证书，它想窃取网站 A 发送给客户端的信息，于是它成为中间人拦截到了 A 传给客户端的证书，然后将其替换为自己的证书。此时客户端浏览器收到的是被中间人掉包后的证书，但由于证书里包含了客户端请求的网站信息，因此客户端浏览器只需要把证书里的域名与自己请求的域名比对一下就知道证书有没有被掉包了。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">篡改：加密签名与原文签名对比；</span><br><span class="line">调包：请求域名与证书域名对比；</span><br></pre></td></tr></table></figure>

<h3 id="12-HTTP-是不保存状态的协议-如何保存用户状态"><a href="#12-HTTP-是不保存状态的协议-如何保存用户状态" class="headerlink" title="12.HTTP 是不保存状态的协议,如何保存用户状态"></a>12.HTTP 是不保存状态的协议,如何保存用户状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.基于Session，服务器创建并保存键值对：SessionId-Session，然后将SessionId下发给客户端，客户端将其存在Cookie中，每次请求带上这个SessionId，服务器就可以将状态和会话联系起来。</span><br><span class="line">2.基于Cookie，服务器发送响应消息时在响应头中设置Set-Cookie字段，存储客户端的状态信息。客户端根据这个字段来创建Cookie并在请求时带上（每个Cookie都包含着客户端的状态信息），从而实现状态保持。</span><br><span class="line">3.二者的区别：后者完全将会话状态存储在浏览器Cookie中。</span><br><span class="line">4.Cookie被禁用了，可以通过重写URL的方式将会话标识放在URL的参数里</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="13-状态码"><a href="#13-状态码" class="headerlink" title="13.状态码"></a>13.状态码</h3><table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th>分类描述</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>指示信息–表示请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>成功–表示请求已被成功处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>重定向–要完成的请求需要进行附加操作</td>
</tr>
<tr>
<td>4XX</td>
<td>客户端错误–请求有语法错误或者请求无法实现，服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>服务器端错误–服务器处理请求出现错误</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">200 请求成功</span><br><span class="line">204 请求成功但无内容返回</span><br><span class="line">206 范围请求成功</span><br><span class="line"></span><br><span class="line">301 永久重定向</span><br><span class="line">30(2|3|7)临时重定向，语义和实现有略微区别；</span><br><span class="line">304 带if-modified-since 请求首部的条件请求，条件没有满足</span><br><span class="line"></span><br><span class="line">400 语法错误（前端挨打）</span><br><span class="line">401 需要认证信息</span><br><span class="line">403 拒绝访问</span><br><span class="line">404 找不到资源</span><br><span class="line">412 除if-modified-since 以外的条件请求，条件未满足</span><br><span class="line"></span><br><span class="line">500 服务器错误（后端挨打）</span><br><span class="line">503 服务器宕机了（DevOps or IT 挨打）</span><br></pre></td></tr></table></figure>

<h3 id="14-HTTP-x2F-1-1-和-HTTP-x2F-1-0-的区别"><a href="#14-HTTP-x2F-1-1-和-HTTP-x2F-1-0-的区别" class="headerlink" title="14.HTTP&#x2F;1.1 和 HTTP&#x2F;1.0 的区别"></a>14.HTTP&#x2F;1.1 和 HTTP&#x2F;1.0 的区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.缓存处理：在 HTTP/1.0 中主要使用 header 里的 if-modified-Since, Expries 来做缓存判断的标准。而 HTTP/1.1 请求头中添加了更多与缓存相关的字段，从而支持更为灵活的缓存策略，例如 Entity-tag, If-Unmodified-Since, If-Match, If-None-Match 等可供选择的缓存头来控制缓存策略。</span><br><span class="line"></span><br><span class="line">2.节约带宽： 当客户端请求某个资源时，HTTP/1.0 默认将该资源相关的整个对象传送给请求方，但很多时候可能客户端并不需要对象的所有信息。而在 HTTP/1.1 的请求头中引入了 range 头域，它允许只请求部分资源，其使得开发者可以多线程请求某一资源，从而充分的利用带宽资源，实现高效并发。</span><br><span class="line"></span><br><span class="line">3.错误通知的管理：HTTP/1.1 在 1.0 的基础上新增了 24 个错误状态响应码，例如 414 表示客户端请求中所包含的 URL 地址太长，以至于服务器无法处理；410 表示所请求的资源已经被永久删除。</span><br><span class="line"></span><br><span class="line">4.Host 请求头：早期 HTTP/1.0 中认为每台服务器都绑定一个唯一的 IP 地址并提供单一的服务，请求消息中的 URL 并没有传递主机名。而随着虚拟主机的出现，一台物理服务器上可以存在多个虚拟主机，并且它们共享同一个 IP 地址。为了支持虚拟主机，HTTP/1.1 中添加了 host 请求头，请求消息和响应消息中应声明这个字段，若请求消息中缺少该字段时服务端会响应一个 404 错误状态码。</span><br><span class="line"></span><br><span class="line">5.长连接：HTTP/1.0 默认浏览器和服务器之间保持短暂连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成后立即断开 TCP 连接。HTTP/1.1 默认使用的是持久连接，其支持在同一个 TCP 请求中传送多个 HTTP 请求和响应。此之前的 HTTP 版本的默认连接都是使用非持久连接，如果想要在旧版本的 HTTP 协议上维持持久连接，则需要指定 Connection 的首部字段的值为 Keep-Alive。</span><br></pre></td></tr></table></figure>

<h3 id="15-HTTP-x2F-1-X-和-HTTP-x2F-2-0-的区别"><a href="#15-HTTP-x2F-1-X-和-HTTP-x2F-2-0-的区别" class="headerlink" title="15.HTTP&#x2F;1.X 和 HTTP&#x2F;2.0 的区别"></a>15.HTTP&#x2F;1.X 和 HTTP&#x2F;2.0 的区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.二进制传送：之前版本 数据都是用文本传输，因为文本有多种格式，所以不能很好地适应所有场景； 2.0传送的是二进制，相当于统一了格式</span><br><span class="line"></span><br><span class="line">2.多路复用：1.1虽然默认复用TCP连接，但是每个请求是串行执行的，如果前面的请求超时，后面的请求只能等着（也就是线头阻塞）； 2.0的时候每个请求有自己的ID，多个请求可以在同一个TCP连接上并行执行，不会互相影响</span><br><span class="line"></span><br><span class="line">3.header压缩：每次进行HTTP请求响应的时候，头部里很多的字段都是重复的，在2.0中，将字段记录到一张表中，头部只需要存放字段对应的编号就行，用的时候只需要拿着编号去表里查找就行，减少了传输的数据量</span><br><span class="line"></span><br><span class="line">4.服务端推送：服务器会在客户端没发起请求的时候主动推送一些需要的资源，比如客户端请求一个html文件，服务器发送完之后会把和这个html页面相关的静态文件也发送给客户端，当客户端准备向服务器请求静态文件的时候，就可以直接从缓存中获取，就不需要再发起请求了</span><br></pre></td></tr></table></figure>

<h3 id="16-域名解析查询的两种方式"><a href="#16-域名解析查询的两种方式" class="headerlink" title="16.域名解析查询的两种方式"></a>16.域名解析查询的两种方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.递归查询：如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户端的身份，向其他根域名服务器继续发出查询请求报文，即替主机继续查询，而不是让主机自己进行下一步查询，如上图步骤（1）和（10）。</span><br><span class="line">2.迭代查询：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应该找哪个域名服务器进行查询，然后让本地服务器进行后续的查询，如上图步骤（2）~（9）</span><br></pre></td></tr></table></figure>

<img src="https://pic.leetcode-cn.com/1632307681-keCKRT-image.png" alt="DNS.png" style="zoom: 25%;" />

<h3 id="17-DNS-为什么用-UDP"><a href="#17-DNS-为什么用-UDP" class="headerlink" title="17.DNS 为什么用 UDP"></a>17.DNS 为什么用 UDP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DNS 既使用 TCP 又使用 UDP。</span><br><span class="line"></span><br><span class="line">当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用 TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。</span><br><span class="line"></span><br><span class="line">当客户端向 DNS 服务器查询域名 ( 域名解析) 的时候，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节。用 UDP 传输时，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度，但这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。</span><br></pre></td></tr></table></figure>

<h3 id="18-实现DNS劫持"><a href="#18-实现DNS劫持" class="headerlink" title="18.实现DNS劫持"></a>18.实现DNS劫持</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">劫持：通过修改计算机的DNS服务器配置将计算机的DNS请求都发到一个恶意的DNS服务器。</span><br><span class="line">预防：直接使用IP访问或者直接指定DNS服务器。</span><br></pre></td></tr></table></figure>

<h3 id="19-socket-套接字有哪些"><a href="#19-socket-套接字有哪些" class="headerlink" title="19.socket() 套接字有哪些"></a>19.socket() 套接字有哪些</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">套接字（Socket）是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象，网络进程通信的一端就是一个套接字，不同主机上的进程便是通过套接字发送报文来进行通信。例如 TCP 用主机的 IP 地址 + 端口号作为 TCP 连接的端点，这个端点就叫做套接字。</span><br><span class="line"></span><br><span class="line">主要有三种类型：流套接字（SOCK_STREAM）、数据报套接字（SOCK_DGRAM）、原始套接字（SOCK_RAW）</span><br><span class="line"></span><br><span class="line">流套接字：基于 TCP 传输协议，主要用于提供面向连接、可靠的数据传输服务。</span><br><span class="line"></span><br><span class="line">数据报套接字：基于 UDP 传输协议，对应于无连接的 UDP 服务应用。</span><br><span class="line"></span><br><span class="line">原始套接字：用来传送非传输层数据包（例如 Ping 命令时用的 ICMP 协议数据包）或者遇到操作系统无法处理的数据包。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="20-URI（统一资源标识符）和-URL（统一资源定位符）之间的区别"><a href="#20-URI（统一资源标识符）和-URL（统一资源定位符）之间的区别" class="headerlink" title="20.URI（统一资源标识符）和 URL（统一资源定位符）之间的区别"></a>20.URI（统一资源标识符）和 URL（统一资源定位符）之间的区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URI：告诉你有这个资源</span><br><span class="line">URL：告诉你这个资源在哪里</span><br><span class="line">简单地说，只要能唯一标识资源的就是 URI，在 URI 的基础上给出其资源的访问方式的就是 URL。</span><br></pre></td></tr></table></figure>

<h3 id="21-如果你访问一个网站很慢，怎么排查和解决"><a href="#21-如果你访问一个网站很慢，怎么排查和解决" class="headerlink" title="21.如果你访问一个网站很慢，怎么排查和解决"></a>21.如果你访问一个网站很慢，怎么排查和解决</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.首先最直接的方法是查看本地网络是否正常</span><br><span class="line">2.当网速测试正常时，我们对网站服务器速度进行排查，通过 ping 命令查看链接到服务器的时间和丢包等情况</span><br><span class="line">3.如果网页打开的速度时快时慢，甚至有时候打不开，有可能是空间不稳定的原因。</span><br><span class="line">4.如果使用了CDN，CDN节点网络质量差也会导致打开慢</span><br><span class="line">5.CDN的解析IP跨网</span><br><span class="line">6.CDN的服务器负载高</span><br><span class="line">7.源站服务器过载或出口带宽被占满</span><br><span class="line">8.DNS解析耗时</span><br></pre></td></tr></table></figure>

<h3 id="22-其他协议"><a href="#22-其他协议" class="headerlink" title="22.其他协议"></a>22.其他协议</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。</span><br><span class="line">TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户/服务器方式，使用 UDP 数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过 Telnet 程序来测试一个 SMTP 服务器。SMTP 使用 TCP 端口 25。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DHCP ( Dynamic Host Configuration Protocol，动态主机设置协议 ) 是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：</span><br><span class="line"></span><br><span class="line">用于内部网络或网络服务供应商自动分配 IP 地址给用户</span><br><span class="line">用于内部网络管理员作为对所有电脑作中央管理的手段</span><br></pre></td></tr></table></figure>

<h3 id="23-网页解析全过程【用户输入网址到显示对应页面的全过程】"><a href="#23-网页解析全过程【用户输入网址到显示对应页面的全过程】" class="headerlink" title="23.网页解析全过程【用户输入网址到显示对应页面的全过程】"></a>23.网页解析全过程【用户输入网址到显示对应页面的全过程】</h3><img src="https://pic.leetcode-cn.com/1612459029-slhrTZ-%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="页面显示流程图.png" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.DNS 解析：当用户输入一个网址并按下回车键的时候，浏览器获得一个域名，而在实际通信过程中，我们需要的是一个 IP 地址，因此我们需要先把域名转换成相应 IP 地址。【具体细节参看问题 16，17】</span><br><span class="line"></span><br><span class="line">2.TCP 连接：浏览器通过 DNS 获取到 Web 服务器真正的 IP 地址后，便向 Web 服务器发起 TCP 连接请求，通过 TCP 三次握手建立好连接后，浏览器便可以将 HTTP 请求数据发送给服务器了。【三次握手放在传输层详细讲解】</span><br><span class="line"></span><br><span class="line">3.发送 HTTP 请求：浏览器向 Web 服务器发起一个 HTTP 请求，HTTP 协议是建立在 TCP 协议之上的应用层协议，其本质是在建立起的TCP连接中，按照HTTP协议标准发送一个索要网页的请求。在这一过程中，会涉及到负载均衡等操作。</span><br><span class="line"></span><br><span class="line">4.处理请求并返回：服务器获取到客户端的 HTTP 请求后，会根据 HTTP 请求中的内容来决定如何获取相应的文件，并将文件发送给浏览器。</span><br><span class="line"></span><br><span class="line">5.浏览器渲染：浏览器根据响应开始显示页面，首先解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</span><br><span class="line"></span><br><span class="line">6.断开连接：客户端和服务器通过四次挥手终止 TCP 连接。【其中的细节放在传输层详细讲解】</span><br></pre></td></tr></table></figure>

<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="1-三次握手和四次挥手机制"><a href="#1-三次握手和四次挥手机制" class="headerlink" title="1.三次握手和四次挥手机制"></a>1.三次握手和四次挥手机制</h3><p>三次握手：</p>
<img src="https://pic.leetcode-cn.com/1614160878-FiFlkq-image.png" alt="image.png"  />



<p>四次挥手：</p>
<img src="https://pic.leetcode-cn.com/1612459478-ajInIu-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手.png" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">三次握手：（建立对话）</span><br><span class="line">成员client:打开对讲机</span><br><span class="line">成员Server:打开对讲机，并开始听对讲机(Listen阶段)</span><br><span class="line">成员client:Server,听得到我说话吗，（发出SYN包,SYN = 1），听到请回答（等待确认seq=x），并开始等待（说完进入SYN-SEND阶段）</span><br><span class="line">成员Server:收到，收到（SYN = 1,ACK = 1）,听的挺清楚（Seq =y, Ack = x+1）,并开始等待（说完进入SYN-RCVD阶段）</span><br><span class="line">成员client：好的，好的（ACK=1），我要开始跟你讲一件事情（Seq = x+1,Ack = y+1）;(进入 ESTABLISHED阶段)</span><br><span class="line">成员Server:默默的点点头，并对自己说可以（进入 ESTABLISHED阶段）</span><br><span class="line"></span><br><span class="line">四次挥手：（结束对讲）</span><br><span class="line">成员client:我事情讲完了，你知道吗（FIN = 1,Seq = u）；（进入FIN-WAIT-1）</span><br><span class="line">成员Server:哦，哦（ACK = 1, Seq = v）,知道了（Ack = u+1）,让我再理一下（进入CLOSE-WAIT）</span><br><span class="line">成员client:对自己默默说了句，好的，等等你（进入FIN-WAIT-2）</span><br><span class="line">成员Server:哦，这个是这么处理对吧，知道了（FIN =1,ACK=1,Seq = w,Ack = u+1）(进入LAST-ACK)</span><br><span class="line">成员client:对的，是的（ACK=1,Seq= u+1,Ack = w+1）,并关掉对讲机（close）</span><br><span class="line">成员server:听到确认和嘟嘟声，关掉对讲机（close）</span><br></pre></td></tr></table></figure>

<h3 id="2-如果三次握手的时候每次握手信息对方没有收到会怎么样"><a href="#2-如果三次握手的时候每次握手信息对方没有收到会怎么样" class="headerlink" title="2.如果三次握手的时候每次握手信息对方没有收到会怎么样"></a>2.如果三次握手的时候每次握手信息对方没有收到会怎么样</h3><img src="https://pic.leetcode-cn.com/1627570368-YNpFKD-image.png" alt="image.png" style="zoom: 67%;" />

<h3 id="3-为什么要进行三次握手？两次握手可以吗？"><a href="#3-为什么要进行三次握手？两次握手可以吗？" class="headerlink" title="3.为什么要进行三次握手？两次握手可以吗？"></a>3.为什么要进行三次握手？两次握手可以吗？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">三次握手的主要目的是确认自己和对方的发送和接收都是正常的，从而保证了双方能够进行可靠通信。若采用两次握手，当第二次握手后就建立连接的话，此时客户端知道服务器能够正常接收到自己发送的数据，而服务器并不知道客户端是否能够收到自己发送的数据。</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.leetcode-cn.com/1627571339-xeuBNe-image.png" alt="image.png"></p>
<h3 id="4-第-2-次握手传回了-ACK，为什么还要传回-SYN"><a href="#4-第-2-次握手传回了-ACK，为什么还要传回-SYN" class="headerlink" title="4.第 2 次握手传回了 ACK，为什么还要传回 SYN"></a>4.第 2 次握手传回了 ACK，为什么还要传回 SYN</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务器端防止SYN泛洪攻击时，回传回一个initial sequence，这个seq以源IP 源端口号，目的地IP，端口号还有只有服务器知道的一个秘密数，经过散列函数散列而来，之后客户端传回的ack号就是用这个序号，由于IP什么的都没有改变，所以可以确认仍然是之前的客户机。所以，从这个角度上，SYN可以理解为是服务器端传回数据的初始序号，也可以说是确认服务器端收到的消息来自于同一个客户机</span><br></pre></td></tr></table></figure>

<h3 id="5-为什么要四次挥手？"><a href="#5-为什么要四次挥手？" class="headerlink" title="5.为什么要四次挥手？"></a>5.为什么要四次挥手？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">释放 TCP 连接时之所以需要四次挥手，是因为 FIN 释放连接报文和 ACK 确认接收报文是分别在两次握手中传输的。 当主动方在数据传送结束后发出连接释放的通知，由于被动方可能还有必要的数据要处理，所以会先返回 ACK 确认收到报文。当被动方也没有数据再发送的时候，则发出连接释放通知，对方确认后才完全关闭TCP连接。</span><br><span class="line"></span><br><span class="line">简单来说就是因为TCP是全双工的，两个方向的连接需要单独关闭。</span><br></pre></td></tr></table></figure>

<h3 id="6-CLOSE-WAIT-和-TIME-WAIT-的状态和意义"><a href="#6-CLOSE-WAIT-和-TIME-WAIT-的状态和意义" class="headerlink" title="6.CLOSE-WAIT 和 TIME-WAIT 的状态和意义"></a>6.CLOSE-WAIT 和 TIME-WAIT 的状态和意义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CLOSE-WAIT:</span><br><span class="line">是服务端发出第一次挥手(整体第二次)进入的状态,表示&quot;我准备关闭了,但是还有自己的事情处理一下,你等我处理完&quot;</span><br><span class="line">等服务器处理好自己的数据业务,则表示我准备好了,再发送 fin 包</span><br><span class="line"></span><br><span class="line">TIME-WAIT:</span><br><span class="line">是第四次挥手后,客户端进入的状态,是客户端必要的等待时间,目的是等待:1-服务端的对应端口关闭与客户端发送到服务端的数据到达(可能出现延迟),如果不存在这个步骤就会导致两个问题:</span><br><span class="line">①客户端立即关闭后,立即又用同样的端口握手并建立通信,此时上次的连接残留的数据包会被误认为是本次的,造成数据异常</span><br><span class="line">②客户端直接关闭后,若服务端重新发送 fin 包,客户端就会回应 RST,会报异常,但是其实只是正常的关闭连接过程，并没有出现异常情况。</span><br></pre></td></tr></table></figure>

<h3 id="7-TIME-WAIT-状态会导致什么问题，怎么解决"><a href="#7-TIME-WAIT-状态会导致什么问题，怎么解决" class="headerlink" title="7.TIME_WAIT 状态会导致什么问题，怎么解决"></a>7.TIME_WAIT 状态会导致什么问题，怎么解决</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修改配置或设置 SO_REUSEADDR 套接字，使得服务器处于 TIME-WAIT 状态下的端口能够快速回收和重用。</span><br></pre></td></tr></table></figure>

<h3 id="8-TIME-WAIT-为什么是-2MSL"><a href="#8-TIME-WAIT-为什么是-2MSL" class="headerlink" title="8.TIME-WAIT 为什么是 2MSL"></a>8.TIME-WAIT 为什么是 2MSL</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 MSL 即是服务器端发出 FIN 报文和客户端发出的 ACK 确认报文所能保持有效的最大时长。</span><br><span class="line"></span><br><span class="line">如果服务器在1MSL后仍然没有收到客户端发送的ACK确认报文，那么它会向客户端重传FIN报文，对客户端而言，从客户端发出ACK报文起，重传的FIN报文的最晚到达时间是2MSL.</span><br></pre></td></tr></table></figure>

<h3 id="9-有很多-TIME-WAIT-状态如何解决"><a href="#9-有很多-TIME-WAIT-状态如何解决" class="headerlink" title="9.有很多 TIME-WAIT 状态如何解决"></a>9.有很多 TIME-WAIT 状态如何解决</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">采用长连接的方式减少 TCP 的连接与断开，在长连接的业务中往往不需要考虑 TIME-WAIT 状态，但其实在长连接的业务中并发量一般不会太高。</span><br></pre></td></tr></table></figure>

<h3 id="10-有很多-CLOSE-WAIT-怎么解决"><a href="#10-有很多-CLOSE-WAIT-怎么解决" class="headerlink" title="10.有很多 CLOSE-WAIT 怎么解决"></a>10.有很多 CLOSE-WAIT 怎么解决</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">首先检查是不是自己的代码问题（看是否服务端程序忘记关闭连接），如果是，则修改代码。</span><br><span class="line">调整系统参数，包括句柄相关参数和 TCP/IP 的参数，一般一个 CLOSE_WAIT 会维持至少 2 个小时的时间，我们可以通过调整参数来缩短这个时间。</span><br></pre></td></tr></table></figure>

<h3 id="11-TCP-和-UDP-的区别"><a href="#11-TCP-和-UDP-的区别" class="headerlink" title="11.TCP 和 UDP 的区别"></a>11.TCP 和 UDP 的区别</h3><table>
<thead>
<tr>
<th>类型</th>
<th><strong>是否面向连接</strong></th>
<th><strong>传输可靠性</strong></th>
<th><strong>传输形式</strong></th>
<th><strong>传输效率</strong></th>
<th><strong>所需资源</strong></th>
<th><strong>应用场景</strong></th>
<th><strong>首部字节</strong></th>
</tr>
</thead>
<tbody><tr>
<td>TCP</td>
<td>是</td>
<td>可靠</td>
<td>字节流</td>
<td>慢</td>
<td>多</td>
<td>文件传输、邮件传输</td>
<td>20~60</td>
</tr>
<tr>
<td>UDP</td>
<td>否</td>
<td>不可靠</td>
<td>数据报文段</td>
<td>快</td>
<td>少</td>
<td>即时通讯、域名转换</td>
<td>8个字节</td>
</tr>
</tbody></table>
<h3 id="12-TCP-协议中的定时器"><a href="#12-TCP-协议中的定时器" class="headerlink" title="12.TCP 协议中的定时器"></a>12.TCP 协议中的定时器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">建立连接定时器，主动方</span><br><span class="line">重传定时器，主被动方</span><br><span class="line">坚持定时器，主被动方</span><br><span class="line">延迟应答定时器，要进行确认的一方</span><br><span class="line">保活定时器，主被动方</span><br><span class="line">FIN_WAIT_2定时器，主动方</span><br><span class="line">TIME_WAIT定时器，主动方</span><br></pre></td></tr></table></figure>

<h3 id="13-TCP-是如何保证可靠性的"><a href="#13-TCP-是如何保证可靠性的" class="headerlink" title="13.TCP 是如何保证可靠性的"></a>13.TCP 是如何保证可靠性的</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.数据分块：应用数据被分割成 TCP 认为最适合发送的数据块。</span><br><span class="line"></span><br><span class="line">2.序列号和确认应答：TCP 给发送的每一个包进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。除此之外，接收方可以根据序列号对数据包进行排序，把有序数据传送给应用层，并丢弃重复的数据。</span><br><span class="line"></span><br><span class="line">3.校验和： TCP 将保持它首部和数据部分的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段并且不确认收到此报文段。</span><br><span class="line"></span><br><span class="line">4.流量控制： TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。</span><br><span class="line"></span><br><span class="line">5.拥塞控制：当网络某个节点发生拥塞时，减少数据的发送。</span><br><span class="line"></span><br><span class="line">6.ARQ协议：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</span><br><span class="line"></span><br><span class="line">7.超时重传：当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TCP虽然是面向字节流的，但TCP传输数据单元却是报文段</span><br><span class="line"></span><br><span class="line">面向字节流的含义是：虽然应用程序和TCP的交互是一次一个数据块(大小不等)，但TCP把应用程序交付下来的数据看成仅仅是一连串的无结构的字节流......</span><br></pre></td></tr></table></figure>

<h3 id="14-UDP-为什么是不可靠的？bind-和-connect-对于-UDP-的作用是什么"><a href="#14-UDP-为什么是不可靠的？bind-和-connect-对于-UDP-的作用是什么" class="headerlink" title="14.UDP 为什么是不可靠的？bind 和 connect 对于 UDP 的作用是什么"></a>14.UDP 为什么是不可靠的？bind 和 connect 对于 UDP 的作用是什么</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UDP 只有一个 socket 接收缓冲区，没有 socket 发送缓冲区，即只要有数据就发，不管对方是否可以正确接收。而在对方的 socket 接收缓冲区满了之后，新来的数据报无法进入到 socket 接受缓冲区，此数据报就会被丢弃，因此 UDP 不能保证数据能够到达目的地，此外，UDP 也没有流量控制和重传机制，故UDP的数据传输是不可靠的。</span><br></pre></td></tr></table></figure>

<h3 id="15-TCP-超时重传的原理"><a href="#15-TCP-超时重传的原理" class="headerlink" title="15.TCP 超时重传的原理"></a>15.TCP 超时重传的原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发送方在发送一次数据后就开启一个定时器，在一定时间内如果没有得到发送数据包的 ACK 报文，那么就重新发送数据，在达到一定次数还没有成功的话就放弃重传并发送一个复位信号。其中超时时间的计算是超时的核心，而定时时间的确定往往需要进行适当的权衡，因为当定时时间过长会造成网络利用率不高，定时太短会造成多次重传，使得网络阻塞。在 TCP 连接过程中，会参考当前的网络状况从而找到一个合适的超时时间。</span><br></pre></td></tr></table></figure>

<h3 id="16-TCP-的停止等待协议是什么"><a href="#16-TCP-的停止等待协议是什么" class="headerlink" title="16.TCP 的停止等待协议是什么"></a>16.TCP 的停止等待协议是什么</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">停止等待协议是为了实现 TCP 可靠传输而提出的一种相对简单的协议，该协议指的是发送方每发完一组数据后，直到收到接收方的确认信号才继续发送下一组数据。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在已发送但未确认的报文被确认之前, 发送方的滑动窗口将不会滑动。</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.leetcode-cn.com/1612460049-DzVGiO-%E6%97%A0%E5%B7%AE%E9%94%99%E5%92%8C%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0.png" alt="无差错和超时重传.png"></p>
<p><img src="https://pic.leetcode-cn.com/1612460087-MRLQIm-%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E5%92%8C%E7%A1%AE%E8%AE%A4%E9%87%8D%E4%BC%A0.png" alt="确认丢失和确认重传.png"></p>
<h3 id="17-TCP-最大连接数限制"><a href="#17-TCP-最大连接数限制" class="headerlink" title="17.TCP 最大连接数限制"></a>17.TCP 最大连接数限制</h3><p>理论上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client 在每次发起 TCP 连接请求时，如果自己并不指定端口的话，系统会随机选择一个本地端口（local port），该端口是独占的，不能和其他 TCP 连接共享。TCP 端口的数据类型是 unsigned short，因此本地端口个数最大只有 65536，除了端口 0不能使用外，其他端口在空闲时都可以正常使用，这样可用端口最多有 65535 个。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server 通常固定在某个本地端口上监听，等待 client 的连接请求。不考虑地址重用（Unix 的 SO_REUSEADDR 选项）的情况下，即使 server 端有多个 IP，本地监听端口也是独占的，因此 server 端 TCP 连接 4 元组中只有客户端的 IP 地址和端口号是可变的，因此最大 TCP 连接为客户端 IP 数 × 客户端 port 数，对 IPV4，在不考虑 IP 地址分类的情况下，最大 TCP 连接数约为 2 的 32 次方（IP 数）× 2 的 16 次方（port 数），也就是 server 端单机最大 TCP 连接数约为 2 的 48 次方。</span><br></pre></td></tr></table></figure>

<p>实际中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在实际环境中，受到明文规定（一些 IP 地址和端口具有特殊含义，没有对外开放）、机器资源、操作系统等的限制，特别是 sever 端，其最大并发 TCP 连接数远不能达到理论上限。对 server 端，通过增加内存、修改最大文件描述符个数等参数，单机最大并发 TCP 连接数超过 10 万 是没问题的。</span><br></pre></td></tr></table></figure>

<h3 id="18-TCP-流量控制与拥塞控制"><a href="#18-TCP-流量控制与拥塞控制" class="headerlink" title="18.TCP 流量控制与拥塞控制"></a>18.TCP 流量控制与拥塞控制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">流量控制:</span><br><span class="line">所谓流量控制就是让发送方的发送速率不要太快，让接收方来得及接收。如果接收方来不及接收发送方发送的数据，那么就会有分组丢失。在 TCP 中利用可变长的滑动窗口机制可以很方便的在 TCP 连接上实现对发送方的流量控制。主要的方式是接收方返回的 ACK 中会包含自己的接收窗口大小，以控制发送方此次发送的数据量大小（发送窗口大小）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">拥塞控制:</span><br><span class="line">在实际的网络通信系统中，除了发送方和接收方外，还有路由器，交换机等复杂的网络传输线路，此时就需要拥塞控制。拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。常用的解决方法有：慢开始和拥塞避免、快重传和快恢复。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">拥塞控制和流量控制的区别:</span><br><span class="line">拥塞控制往往是一种全局的，防止过多的数据注入到网络之中，而TCP连接的端点只要不能收到对方的确认信息，猜想在网络中发生了拥塞，但并不知道发生在何处，因此，流量控制往往指点对点通信量的控制，是端到端的问题。</span><br></pre></td></tr></table></figure>

<h3 id="19-如果接收方滑动窗口满了，发送方会怎么做"><a href="#19-如果接收方滑动窗口满了，发送方会怎么做" class="headerlink" title="19.如果接收方滑动窗口满了，发送方会怎么做"></a>19.如果接收方滑动窗口满了，发送方会怎么做</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基于 TCP 流量控制中的滑动窗口协议，我们知道接收方返回给发送方的 ACK 包中会包含自己的接收窗口大小，若接收窗口已满，此时接收方返回给发送方的接收窗口大小为 0，此时发送方会等待接收方发送的窗口大小直到变为非 0 为止，然而，接收方回应的 ACK 包是存在丢失的可能的，为了防止双方一直等待而出现死锁情况，此时就需要坚持计时器来辅助发送方周期性地向接收方查询，以便发现窗口是否变大【坚持计时器参考问题】，当发现窗口大小变为非零时，发送方便继续发送数据。</span><br></pre></td></tr></table></figure>

<h3 id="20-TCP-拥塞控制采用的四种算法"><a href="#20-TCP-拥塞控制采用的四种算法" class="headerlink" title="20.TCP 拥塞控制采用的四种算法"></a>20.TCP 拥塞控制采用的四种算法</h3><p><img src="https://pic.leetcode-cn.com/1618208921-kuMbas-image.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">慢开始，拥塞避免，快重传，快恢复。</span><br></pre></td></tr></table></figure>

<h3 id="21-TCP-粘包问题"><a href="#21-TCP-粘包问题" class="headerlink" title="21.TCP 粘包问题"></a>21.TCP 粘包问题</h3><p><strong>为什么会发生TCP粘包和拆包?</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">① 发送方写入的数据大于套接字缓冲区的大小，此时将发生拆包。</span><br><span class="line"></span><br><span class="line">② 发送方写入的数据小于套接字缓冲区大小，由于 TCP 默认使用 Nagle 算法，只有当收到一个确认后，才将分组发送给对端，当发送方收集了多个较小的分组，就会一起发送给对端，这将会发生粘包。</span><br><span class="line"></span><br><span class="line">③ 进行 MSS （最大报文长度）大小的 TCP 分段，当 TCP 报文的数据部分大于 MSS 的时候将发生拆包。</span><br><span class="line"></span><br><span class="line">④ 发送方发送的数据太快，接收方处理数据的速度赶不上发送端的速度，将发生粘包。</span><br></pre></td></tr></table></figure>

<p><strong>常见解决方法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">① 在消息的头部添加消息长度字段，服务端获取消息头的时候解析消息长度，然后向后读取相应长度的内容。</span><br><span class="line"></span><br><span class="line">② 固定消息数据的长度，服务端每次读取既定长度的内容作为一条完整消息，当消息不够长时，空位补上固定字符。但是该方法会浪费网络资源。</span><br><span class="line"></span><br><span class="line">③ 设置消息边界，也可以理解为分隔符，服务端从数据流中按消息边界分离出消息内容，一般使用换行符。</span><br></pre></td></tr></table></figure>



<p><strong>什么时候需要处理粘包问题？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当接收端同时收到多个分组，并且这些分组之间毫无关系时，需要处理粘包；而当多个分组属于同一数据的不同部分时，并不需要处理粘包问题。</span><br></pre></td></tr></table></figure>

<p><strong>关于TCP没有包</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.单看传输层，TCP是「面向字节流」传输的，本身是没有「包」的概念的，接收方将接收的报文段（segment）的数据提取出来按序放置在缓存中。</span><br><span class="line">2.但是从应用层的角度看是有「包」的概念的，例如http/1.1中采用了「管道(pipeline)」的思想，即可以多个http数据流「复用」同一个TCP，因此各个http数据流之间是「纠缠」的，那么就需要在应用层进行处理，「区分不同」的数据流，自然就需要处理「粘包」的问题。</span><br><span class="line">3.个人认为TCP层没有「包」的概念反映了TCP层对应用层「多数据流」的支持较弱，这恰恰导致了粘包问题。而这种弱势也导致了HTTP/3转向了QUIC，也就是基于UDP，自行实现更好的「多数据流复用/分用」。</span><br></pre></td></tr></table></figure>

<h3 id="22-TCP-报文包含哪些信息"><a href="#22-TCP-报文包含哪些信息" class="headerlink" title="22.TCP 报文包含哪些信息"></a>22.TCP 报文包含哪些信息</h3><p><img src="https://pic.leetcode-cn.com/1612460289-ImAroH-TCP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt="TCP报文格式.png"></p>
<h3 id="23-SYN-FLOOD-是什么"><a href="#23-SYN-FLOOD-是什么" class="headerlink" title="23.SYN FLOOD 是什么"></a>23.SYN FLOOD 是什么</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SYN Flood 是种典型的 DoS（拒绝服务）攻击，其目的是通过消耗服务器所有可用资源使服务器无法用于处理合法请求。通过重复发送初始连接请求（SYN）数据包，攻击者能够压倒目标服务器上的所有可用端口，导致目标设备根本不响应合法请求。</span><br></pre></td></tr></table></figure>

<h3 id="24-为什么服务端易受到-SYN-攻击"><a href="#24-为什么服务端易受到-SYN-攻击" class="headerlink" title="24.为什么服务端易受到 SYN 攻击"></a>24.为什么服务端易受到 SYN 攻击</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在 TCP 建立连接的过程中，因为服务端不确定自己发给客户端的 SYN-ACK 消息或客户端反馈的 ACK 消息是否会丢在半路，所以会给每个待完成的半开连接状态设一个定时器，如果超过时间还没有收到客户端的 ACK 消息，则重新发送一次 SYN-ACK 消息给客户端，直到重试超过一定次数时才会放弃。</span><br><span class="line"></span><br><span class="line">服务端为了维持半开连接状态，需要分配内核资源维护半开连接。当攻击者伪造海量的虚假 IP 向服务端发送 SYN 包时，就形成了 SYN FLOOD 攻击。攻击者故意不响应 ACK 消息，导致服务端被大量注定不能完成的半开连接占据，直到资源耗尽，停止响应正常的连接请求。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line"></span><br><span class="line">直接的方法是提高 TCP 端口容量的同时减少半开连接的资源占用时间，然而该方法只是稍稍提高了防御能力；</span><br><span class="line">部署能够辨别恶意 IP 的路由器，将伪造 IP 地址的发送方发送的 SYN 消息过滤掉，该方案作用一般不是太大；</span><br></pre></td></tr></table></figure>

<h3 id="25-高并发服务器客户端主动关闭连接和服务端主动关闭连接的区别"><a href="#25-高并发服务器客户端主动关闭连接和服务端主动关闭连接的区别" class="headerlink" title="25.高并发服务器客户端主动关闭连接和服务端主动关闭连接的区别"></a>25.高并发服务器客户端主动关闭连接和服务端主动关闭连接的区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">以下是针对 TCP 服务来说的：</span><br><span class="line"></span><br><span class="line">1.服务端主动关闭连接</span><br><span class="line">在高并发场景下，当服务端主动关闭连接时，此时服务器上就会有大量的连接处于 TIME-WAIT 状态【详解见问题 7, 8, 9】</span><br><span class="line"></span><br><span class="line">2.客户端主动关闭连接</span><br><span class="line">当客户端主动关闭连接时，我们并不需要关心 TIME-WAIT 状态过多造成的问题，但是需要关注服务端保持大量的 CLOSE-WAIT 状态时会产生的问题【见问题 10 的解决方法】</span><br><span class="line"></span><br><span class="line">无论是客户端还是服务器主动关闭连接，从本质上来说，在高并发场景下主要关心的就是服务端的资源占用问题，而这也是采用 TCP 传输协议必须要面对的问题，其问题解决的出发点也是如何处理好服务质量和资源消耗之间的关系。</span><br><span class="line"></span><br></pre></td></tr></table></figure>


    </article>
    <!-- license -->
    
        <div class="license-wrapper">
            <p>Author：<a href="http://example.com">John Doe</a>
            <p>Link：<a href="http://example.com/2022/05/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">http://example.com/2022/05/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</a>
            <p>Publish date：<a href="http://example.com/2022/05/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">May 9th 2022, 8:14:40 pm</a>
            <p>Update date：<a href="http://example.com/2022/05/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">May 9th 2022, 8:36:01 pm</a>
            <p>License：本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator -->
    <ul class="post-paginator">
        <li class="next">
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href="/2022/05/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/" title="我的第一篇博客">
                    <div class="prevTitle">我的第一篇博客</div>
                </a>
            
        </li>
    </ul>
    <!-- comment -->
    
        <div class="post-comment">
            <!-- 来必力 City 版安装代码 -->


            

            

            

            <!-- utteranc评论 -->


            <!-- partial('_partial/comment/changyan') -->
            <!--PC版-->


            
            

            

        </div>
    
    <!-- timeliness note -->
    <!-- idea from: https://hexo.fluid-dev.com/posts/hexo-injector/#%E6%96%87%E7%AB%A0%E6%97%B6%E6%95%88%E6%80%A7%E6%8F%90%E7%A4%BA -->
    
    <!-- Mathjax -->
    
</main>

                <!-- profile -->
                
            </div>
            <footer class="footer footer-unloaded">
    <!-- social  -->
    
        <div class="social">
            
    
        
            
                <a href="mailto:wangruonan@mail.ustc.edu.cn" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/ustcwrn" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                    
                    <img class="profile-qr" src="/assets/example_qr.png" />
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    


        </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- website approve for Chinese user -->
    
    <!-- 不蒜子  -->
    
        <div class="busuanzi-container">
            
             
                <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
            
        </div>
    	
</footer>

        </div>
        <!-- toc -->
        
            <div class="toc-wrapper toc-wrapper-loding" style=







    top:50vh;

>
                <div class="toc-catalog">
                    <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
                </div>
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text">应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-HTTP-%E5%A4%B4%E9%83%A8%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E4%BF%A1%E6%81%AF"><span class="toc-number">1.1.</span> <span class="toc-text">1.HTTP 头部包含哪些信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Keep-Alive-%E5%92%8C%E9%9D%9E-Keep-Alive-%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%AF%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%9C%89%E5%BD%B1%E5%93%8D%E5%90%97"><span class="toc-number">1.2.</span> <span class="toc-text">2.Keep-Alive 和非 Keep-Alive 区别，对服务器性能有影响吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-HTTP-%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%9F%AD%E8%BF%9E%E6%8E%A5%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.</span> <span class="toc-text">3.HTTP 长连接短连接使用场景是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93-HTTP-%E7%9A%84%E6%8A%A5%E6%96%87%E9%95%BF%E5%BA%A6"><span class="toc-number">1.4.</span> <span class="toc-text">4.怎么知道 HTTP 的报文长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-HTTP-%E6%96%B9%E6%B3%95%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B"><span class="toc-number">1.5.</span> <span class="toc-text">5.HTTP 方法了解哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-GET-%E5%92%8C-POST-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.</span> <span class="toc-text">6.GET 和 POST 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-GET-%E7%9A%84%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-number">1.7.</span> <span class="toc-text">7.GET 的长度限制是多少</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-HTTP-%E4%B8%8E-HTTPs-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%E3%80%90%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%91"><span class="toc-number">1.8.</span> <span class="toc-text">8.HTTP 与 HTTPs 的工作方式【建立连接的过程】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-HTTPS-%E5%92%8C-HTTP-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.</span> <span class="toc-text">9.HTTPS 和 HTTP 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-HTTPS-%E7%9A%84%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.10.</span> <span class="toc-text">10.HTTPS 的加密方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BF%A1%E4%BB%BB%E7%AC%AC%E4%B8%89%E6%96%B9%E8%AF%81%E4%B9%A6"><span class="toc-number">1.11.</span> <span class="toc-text">11.客户端为什么信任第三方证书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-HTTP-%E6%98%AF%E4%B8%8D%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%8F%E8%AE%AE-%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81"><span class="toc-number">1.12.</span> <span class="toc-text">12.HTTP 是不保存状态的协议,如何保存用户状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">1.13.</span> <span class="toc-text">13.状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-HTTP-x2F-1-1-%E5%92%8C-HTTP-x2F-1-0-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.14.</span> <span class="toc-text">14.HTTP&#x2F;1.1 和 HTTP&#x2F;1.0 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-HTTP-x2F-1-X-%E5%92%8C-HTTP-x2F-2-0-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.15.</span> <span class="toc-text">15.HTTP&#x2F;1.X 和 HTTP&#x2F;2.0 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.16.</span> <span class="toc-text">16.域名解析查询的两种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-DNS-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-UDP"><span class="toc-number">1.17.</span> <span class="toc-text">17.DNS 为什么用 UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E5%AE%9E%E7%8E%B0DNS%E5%8A%AB%E6%8C%81"><span class="toc-number">1.18.</span> <span class="toc-text">18.实现DNS劫持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-socket-%E5%A5%97%E6%8E%A5%E5%AD%97%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.19.</span> <span class="toc-text">19.socket() 套接字有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-URI%EF%BC%88%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%89%E5%92%8C-URL%EF%BC%88%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6%EF%BC%89%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.20.</span> <span class="toc-text">20.URI（统一资源标识符）和 URL（统一资源定位符）之间的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%A6%82%E6%9E%9C%E4%BD%A0%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%E5%BE%88%E6%85%A2%EF%BC%8C%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5%E5%92%8C%E8%A7%A3%E5%86%B3"><span class="toc-number">1.21.</span> <span class="toc-text">21.如果你访问一个网站很慢，怎么排查和解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E5%85%B6%E4%BB%96%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.22.</span> <span class="toc-text">22.其他协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E7%BD%91%E9%A1%B5%E8%A7%A3%E6%9E%90%E5%85%A8%E8%BF%87%E7%A8%8B%E3%80%90%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E5%AF%B9%E5%BA%94%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B%E3%80%91"><span class="toc-number">1.23.</span> <span class="toc-text">23.网页解析全过程【用户输入网址到显示对应页面的全过程】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text">传输层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">2.1.</span> <span class="toc-text">1.三次握手和四次挥手机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E6%9E%9C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E6%97%B6%E5%80%99%E6%AF%8F%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BF%A1%E6%81%AF%E5%AF%B9%E6%96%B9%E6%B2%A1%E6%9C%89%E6%94%B6%E5%88%B0%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="toc-number">2.2.</span> <span class="toc-text">2.如果三次握手的时候每次握手信息对方没有收到会怎么样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8F%AF%E4%BB%A5%E5%90%97%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">3.为什么要进行三次握手？两次握手可以吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%AC%AC-2-%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BC%A0%E5%9B%9E%E4%BA%86-ACK%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E4%BC%A0%E5%9B%9E-SYN"><span class="toc-number">2.4.</span> <span class="toc-text">4.第 2 次握手传回了 ACK，为什么还要传回 SYN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">5.为什么要四次挥手？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-CLOSE-WAIT-%E5%92%8C-TIME-WAIT-%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E6%84%8F%E4%B9%89"><span class="toc-number">2.6.</span> <span class="toc-text">6.CLOSE-WAIT 和 TIME-WAIT 的状态和意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-TIME-WAIT-%E7%8A%B6%E6%80%81%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">2.7.</span> <span class="toc-text">7.TIME_WAIT 状态会导致什么问题，怎么解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-TIME-WAIT-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-2MSL"><span class="toc-number">2.8.</span> <span class="toc-text">8.TIME-WAIT 为什么是 2MSL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%9C%89%E5%BE%88%E5%A4%9A-TIME-WAIT-%E7%8A%B6%E6%80%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">2.9.</span> <span class="toc-text">9.有很多 TIME-WAIT 状态如何解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%9C%89%E5%BE%88%E5%A4%9A-CLOSE-WAIT-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">2.10.</span> <span class="toc-text">10.有很多 CLOSE-WAIT 怎么解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-TCP-%E5%92%8C-UDP-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.11.</span> <span class="toc-text">11.TCP 和 UDP 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-TCP-%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">2.12.</span> <span class="toc-text">12.TCP 协议中的定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-TCP-%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84"><span class="toc-number">2.13.</span> <span class="toc-text">13.TCP 是如何保证可靠性的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-UDP-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E9%9D%A0%E7%9A%84%EF%BC%9Fbind-%E5%92%8C-connect-%E5%AF%B9%E4%BA%8E-UDP-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.14.</span> <span class="toc-text">14.UDP 为什么是不可靠的？bind 和 connect 对于 UDP 的作用是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-TCP-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.15.</span> <span class="toc-text">15.TCP 超时重传的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-TCP-%E7%9A%84%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.16.</span> <span class="toc-text">16.TCP 的停止等待协议是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-TCP-%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0%E9%99%90%E5%88%B6"><span class="toc-number">2.17.</span> <span class="toc-text">17.TCP 最大连接数限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-TCP-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">2.18.</span> <span class="toc-text">18.TCP 流量控制与拥塞控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E5%A6%82%E6%9E%9C%E6%8E%A5%E6%94%B6%E6%96%B9%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%BB%A1%E4%BA%86%EF%BC%8C%E5%8F%91%E9%80%81%E6%96%B9%E4%BC%9A%E6%80%8E%E4%B9%88%E5%81%9A"><span class="toc-number">2.19.</span> <span class="toc-text">19.如果接收方滑动窗口满了，发送方会怎么做</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E9%87%87%E7%94%A8%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%AE%97%E6%B3%95"><span class="toc-number">2.20.</span> <span class="toc-text">20.TCP 拥塞控制采用的四种算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-TCP-%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.21.</span> <span class="toc-text">21.TCP 粘包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-TCP-%E6%8A%A5%E6%96%87%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E4%BF%A1%E6%81%AF"><span class="toc-number">2.22.</span> <span class="toc-text">22.TCP 报文包含哪些信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-SYN-FLOOD-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.23.</span> <span class="toc-text">23.SYN FLOOD 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%98%93%E5%8F%97%E5%88%B0-SYN-%E6%94%BB%E5%87%BB"><span class="toc-number">2.24.</span> <span class="toc-text">24.为什么服务端易受到 SYN 攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%BB%E5%8A%A8%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%BB%E5%8A%A8%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.25.</span> <span class="toc-text">25.高并发服务器客户端主动关闭连接和服务端主动关闭连接的区别</span></a></li></ol></li></ol>
            </div>
        
        <!-- sidebar -->
        <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
        <div class="sidebar-panel-archives">
    <!-- 在 ejs 中将 archive 按照时间排序 -->
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
        
        
        
        
        
        
        
        
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 3
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
        
            
            
            <div class="archive-year"> 2022 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/09</span>
            <a class="archive-post-title" href="/2022/05/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/09</span>
            <a class="archive-post-title" href="/2022/05/09/hello-world/">Hello World</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/09</span>
            <a class="archive-post-title" href="/2022/05/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/">我的第一篇博客</a>
        </li>
    
    </div>
</div>

        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
        
            <span class="sidebar-tag-name" data-tags="计算机网络">
                <span class="iconfont-archer">&#xe606;</span>
                计算机网络
            </span>
        
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
        缺失模块，请参考主题文档进行安装配置：https://github.com/fi3ework/hexo-theme-archer#%E5%AE%89%E8%A3%85%E4%B8%BB%E9%A2%98
    </div> 
    <div class="sidebar-tags-list"></div>
</div>

        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>

    </div>
</div>

        <!-- site-meta -->
        <script>
    var siteMetaRoot = "/"
    if (siteMetaRoot === "undefined") {
        siteMetaRoot = '/'
    }
    var siteMeta = {
        url: "http://example.com",
        root: siteMetaRoot,
        author: "John Doe"
    }
</script>

        <!-- import experimental options here -->
        <!-- Custom Font -->


        <!-- main func -->
        <script src="/scripts/main.js?v=20211217"></script>
        <!-- dark mode -->
        <script src="/scripts/dark.js?v=20211217"></script>
        <!-- fancybox -->
        <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" defer></script>
        <!-- algolia -->
        
        <!-- busuanzi -->
        
            <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
        
        <!-- CNZZ -->
        
        <!-- async load share.js -->
        
            <script src="/scripts/share.js?v=20211217" async></script>
        
        <!-- mermaid -->
        
    </body>
</html>
